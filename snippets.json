{
  "$camera->make()": {
    "prefix": "make()",
    "body": "make()",
    "description": "Returns the camera brand/make"
  },
  "$camera->model()": {
    "prefix": "model()",
    "body": "model()",
    "description": "Returns the name of the camera model"
  },
  "$camera->toArray()": {
    "prefix": "toArray()",
    "body": "toArray()",
    "description": "Returns the make and model as associative array."
  },
  "$content->data()": {
    "prefix": "data() ",
    "body": "data()",
    "description": "Returns the entire data array with all field objects"
  },
  "$content([$lang])->exists()": {
    "prefix": "exists() ",
    "body": "exists()",
    "description": "Checks if the content file exists"
  },
  "$content([$lang])->fields()": {
    "prefix": "fields() ",
    "body": "fields()",
    "description": "Returns an array with all field names"
  },
  "$content([$lang])->get($key, $arguments = null)": {
    "prefix": "get() ",
    "body": "get(${1:$key}, ${2:$arguments})${3}",
    "description": "Gets a field from the content"
  },
  "$content([$lang])->has($key)": {
    "prefix": "has() ",
    "body": "has(${1:$key})",
    "description": "Checks if a field exists"
  },
  "$content->language()": {
    "prefix": "language() ",
    "body": "language()",
    "description": "Return the language code for the content"
  },
  "$content->name()": {
    "prefix": "name() ",
    "body": "name()",
    "description": "Returns the name of the content file without the extension. This is being used to determine the template for the page"
  },
  "$content([$lang])->raw()": {
    "prefix": "raw() ",
    "body": "raw()",
    "description": "Returns the raw content from the file"
  },
  "$content([$lang])->root()": {
    "prefix": "root() ",
    "body": "root()",
    "description": "Returns the root for the content file"
  },
  "$content([$lang])->toArray()": {
    "prefix": "toArray() ",
    "body": "toArray()",
    "description": "Returns the content object as array"
  },
  "$dimension->fit()": {
    "prefix": "fit()  ",
    "body": "fit()",
    "description": "Fits the width and height into a box by the given value and returns a modified dimension object"
  },
  "$dimension->fitHeight()": {
    "prefix": "fitHeight()  ",
    "body": "fitHeight()",
    "description": "Fits the height by the given value and returns a modified dimension object"
  },
  "$dimension->fitWidth()": {
    "prefix": "fitWidth()  ",
    "body": "fitWidth()",
    "description": "Fits the width by the given value and returns a modified dimension object"
  },
  "$dimension->fitWidthAndHeight()": {
    "prefix": "fitWidthAndHeight()  ",
    "body": "fitWidthAndHeight()",
    "description": "Fits the width and height by the given values and returns a modified dimension object"
  },
  "$dimension->height()": {
    "prefix": "height()  ",
    "body": "height()",
    "description": "Returns the height in pixels"
  },
  "$dimension->landscape()": {
    "prefix": "landscape()  ",
    "body": "landscape()",
    "description": "Checks if the dimensions are \"landscape\""
  },
  "$dimension->orientation()": {
    "prefix": "orientation()  ",
    "body": "orientation()",
    "description": "Returns the orientation of the image as string (landscape|portrait|square)"
  },
  "$dimension->portrait()": {
    "prefix": "portrait()  ",
    "body": "portrait()",
    "description": "Checks if the dimensions are \"portrait\""
  },
  "$dimension->ratio()": {
    "prefix": "ratio()  ",
    "body": "ratio()",
    "description": "Returns the ratio"
  },
  "$dimension->square()": {
    "prefix": "square()  ",
    "body": "square()",
    "description": "Checks if the dimensions are square"
  },
  "$dimension->width()": {
    "prefix": "width()  ",
    "body": "width()",
    "description": "Returns the width in pixels"
  },
  "$exif->aperture()": {
    "prefix": "aperture()   ",
    "body": "aperture()",
    "description": "Returns the aperture value of the image, if it is available in the exif data set."
  },
  "$exif->camera()": {
    "prefix": "camera()   ",
    "body": "camera()",
    "description": "Returns the $camera object for the image, which contains the make and model."
  },
  "$exif->data()": {
    "prefix": "data()   ",
    "body": "data()",
    "description": "Returns the full exif data set as a raw array."
  },
  "$exif->exposure()": {
    "prefix": "exposure()   ",
    "body": "exposure()",
    "description": "Returns the exposure value of the image, if it is available in the exif data set."
  },
  "$exif->focalLength()": {
    "prefix": "focalLength()   ",
    "body": "focalLength()",
    "description": "Returns the focal length of the image, if it is available in the exif data set."
  },
  "$exif->isBW()": {
    "prefix": "isBW()   ",
    "body": "isBW()",
    "description": "Checks if the image colorspace is grayscale"
  },
  "$exif->isColor()": {
    "prefix": "isColor()   ",
    "body": "isColor()",
    "description": "Checks if the image colorspace is either RGB or CMYK"
  },
  "$exif->iso()": {
    "prefix": "iso()   ",
    "body": "iso()",
    "description": "Returns the iso value of the image, if it is available in the exif data set."
  },
  "$exif->location()": {
    "prefix": "location()   ",
    "body": "location()",
    "description": "Returns the $location object for the image if the image has GPS data."
  },
  "$exif->timestamp()": {
    "prefix": "timestamp()   ",
    "body": "timestamp()",
    "description": "Returns the unix timestamp of when the image was taken."
  },
  "$exif->toArray()": {
    "prefix": "toArray()   ",
    "body": "toArray()",
    "description": "Returns an associative array of all available exif data."
  },
  "$field->bool()": {
    "prefix": "bool()    ",
    "body": "bool()",
    "description": "Converts the field value into a proper boolean"
  },
  "$field->empty()": {
    "prefix": "empty()    ",
    "body": "empty()",
    "description": "Checks if the field is empty"
  },
  "$field->escape()": {
    "prefix": "escape()    ",
    "body": "escape()",
    "description": "Escapes all critical characters from the field content to make sure all you get is clean HTML"
  },
  "$field->excerpt($length = 140, $mode = 'chars')": {
    "prefix": "excerpt()    ",
    "body": "excerpt(${1:$length = 140}, ${2:$mode = 'chars'})${3}",
    "description": "Creates a short text excerpt"
  },
  "$field->exists()": {
    "prefix": "exists()    ",
    "body": "exists()",
    "description": "Checks if the field exists."
  },
  "$field->float()": {
    "prefix": "float()    ",
    "body": "float()",
    "description": "Converts the field value into a proper float"
  },
  "$field->html()": {
    "prefix": "html()    ",
    "body": "html()",
    "description": "Converts the field content to valid HTML"
  },
  "$field->int()": {
    "prefix": "int()    ",
    "body": "int()",
    "description": "Converts the field value into a proper integer"
  },
  "$field->isEmpty()": {
    "prefix": "isEmpty()    ",
    "body": "isEmpty()",
    "description": "Checks if the field is empty"
  },
  "$field->isFalse()": {
    "prefix": "isFalse()    ",
    "body": "isFalse()",
    "description": "Converts the field value into a proper boolean and inverts it"
  },
  "$field->isNotEmpty()": {
    "prefix": "isNotEmpty()    ",
    "body": "isNotEmpty()",
    "description": "Checks if the field is not empty"
  },
  "$field->isTranslated($lang = null)": {
    "prefix": "isTranslated()    ",
    "body": "isTranslated(${1:$lang = null})${2}",
    "description": "Checks if the field is translated in the current/specified language"
  },
  "$field->isTrue()": {
    "prefix": "isTrue()    ",
    "body": "isTrue()",
    "description": "Converts the field value into a proper boolean"
  },
  "$field->key()": {
    "prefix": "key()    ",
    "body": "key()",
    "description": "Returns the name of the field."
  },
  "$field->kirbytext()": {
    "prefix": "kirbytext()    ",
    "body": "kirbytext()",
    "description": "Converts the field content from Markdown/Kirbytext to valid HTML"
  },
  "$field->kt()": {
    "prefix": "kt()    ",
    "body": "kt()",
    "description": "Converts the field content from Markdown/Kirbytext to valid HTML"
  },
  "$field->length()": {
    "prefix": "length()    ",
    "body": "length()",
    "description": "Returns the length of the field content"
  },
  "$field->link()": {
    "prefix": "link()    ",
    "body": "link()",
    "description": "Creates a link for any field value"
  },
  "$field->lower()": {
    "prefix": "lower()    ",
    "body": "lower()",
    "description": "Converts the field content to lowercase"
  },
  "$field->markdown()": {
    "prefix": "markdown()    ",
    "body": "markdown()",
    "description": "Converts markdown to valid HTML"
  },
  "$field->or($alternative)": {
    "prefix": "or()    ",
    "body": "or(${1:$alternative})${2}",
    "description": "Checks if the field is empty and returns an alternative value in this case"
  },
  "$field->pages()": {
    "prefix": "pages()    ",
    "body": "pages()",
    "description": "Converts a yaml list of page URIs to valid page objects"
  },
  "$field->short($chars)": {
    "prefix": "short()    ",
    "body": "short(${1:$chars})${2}",
    "description": "Shortens the field content by the given length"
  },
  "$field->smartypants()": {
    "prefix": "smartypants()    ",
    "body": "smartypants()",
    "description": "Applies SmartyPants to the field"
  },
  "$field->split($separator = ',')": {
    "prefix": "split()    ",
    "body": "split(${1:$separator = ','})${2}",
    "description": "Splits the field content into an array"
  },
  "$field->toFile()": {
    "prefix": "toFile()    ",
    "body": "toFile()",
    "description": "Returns a file object from a filename in the field"
  },
  "$field->toPage()": {
    "prefix": "toPage()    ",
    "body": "toPage()",
    "description": "Returns a page object from a uri in the field"
  },
  "$field->toStructure()": {
    "prefix": "toStructure()    ",
    "body": "toStructure()",
    "description": "Converts a yaml field to a Structure object"
  },
  "$field->toURL()": {
    "prefix": "toURL()    ",
    "body": "toURL()",
    "description": "Creates an URL for any field value"
  },
  "$field->upper()": {
    "prefix": "upper()    ",
    "body": "upper()",
    "description": "Converts the field content to uppercase"
  },
  "$field->value()": {
    "prefix": "value()    ",
    "body": "value()",
    "description": "Returns the value of a field as string."
  },
  "$field->widont()": {
    "prefix": "widont()    ",
    "body": "widont()",
    "description": "Avoids typographical widows in strings by replacing the last space with &nbsp;"
  },
  "$field->words()": {
    "prefix": "words()    ",
    "body": "words()",
    "description": "Returns the number of words in the text"
  },
  "$field->xml()": {
    "prefix": "xml()    ",
    "body": "xml()",
    "description": "Converts the field content to valid XML"
  },
  "$field->yaml()": {
    "prefix": "yaml()    ",
    "body": "yaml()",
    "description": "Converts YAML-structured field content to an array"
  },
  "$file->append($content)": {
    "prefix": "append()     ",
    "body": "append(${1:$content})${2}",
    "description": "Appends the content and saves the file"
  },
  "$file->base64()": {
    "prefix": "base64()     ",
    "body": "base64()",
    "description": "Returns the content of the file as base64 encoded string"
  },
  "$file->blur()": {
    "prefix": "blur()     ",
    "body": "blur()",
    "description": "Applies a blur filter to the image"
  },
  "$file->bw($bw)": {
    "prefix": "bw()     ",
    "body": "bw(${1:$bw})${2}",
    "description": "Converts the image to grayscale"
  },
  "$file->content($content = null, $format = null)": {
    "prefix": "content()     ",
    "body": "content(${1:$content = null}, ${2:$format = null})${3}",
    "description": "Setter and getter for the file content"
  },
  "$file->copy($to)": {
    "prefix": "copy()     ",
    "body": "copy(${1:$to})${2}",
    "description": "Copies the file to a new location"
  },
  "$file->createNewFilename($name, $safeName = true)": {
    "prefix": "createNewFilename()     ",
    "body": "createNewFilename(${1:$name}, ${2:$safeName = true})${3}",
    "description": "Generates a new filename for a given name and makes sure to handle badly given extensions correctly"
  },
  "$file->crop($width, $height = null, $quality = null)": {
    "prefix": "crop()     ",
    "body": "crop(${1:$width}, ${2:$height = null}, ${3:$quality = null})${4}",
    "description": "Crops the image by width and optionally by height"
  },
  "$file->dataUri()": {
    "prefix": "dataUri()     ",
    "body": "dataUri()",
    "description": "Returns a full base64 encoded data uri with a proper mime type"
  },
  "$file->date($format = null, $field = 'date')": {
    "prefix": "date()     ",
    "body": "date(${1:$format = null}, ${2:$field = 'date'})${3}",
    "description": "Returns a unix timestamp or formatted date string from the file's meta date field or any other field containing a parsable date"
  },
  "$file->delete()": {
    "prefix": "delete()     ",
    "body": "delete()",
    "description": "Deletes the file. This cannot be undone."
  },
  "$file->dimensions()": {
    "prefix": "dimensions()     ",
    "body": "dimensions()",
    "description": "Returns the $dimensions object for the file. This is only available for images (jpg, png, gif)"
  },
  "$file->dir()": {
    "prefix": "dir()     ",
    "body": "dir()",
    "description": "Returns the full path for the directory, in which the file is located"
  },
  "$file->diruri()": {
    "prefix": "diruri()     ",
    "body": "diruri()",
    "description": "Returns the relative path for the file"
  },
  "$file->download($filename = null)": {
    "prefix": "download()     ",
    "body": "download(${1:$filename = null})",
    "description": "Sends all needed headers and the content to force the browser to download the file"
  },
  "$file->exif()": {
    "prefix": "exif()     ",
    "body": "exif()",
    "description": "Returns the $exif object for the file, which can be used to fetch information such as the camera model or GPS data"
  },
  "$file->exists()": {
    "prefix": "exists()     ",
    "body": "exists()",
    "description": "Checks if the file exists"
  },
  "$file->extension()": {
    "prefix": "extension()     ",
    "body": "extension()",
    "description": "Returns the file extension"
  },
  "$file->filename()": {
    "prefix": "filename()     ",
    "body": "filename()",
    "description": "Returns the full filename including extension"
  },
  "$file->files()": {
    "prefix": "files()     ",
    "body": "files()",
    "description": "Returns the collection of sibling files including the current object"
  },
  "$file->hasNext()": {
    "prefix": "hasNext()     ",
    "body": "hasNext()",
    "description": "Checks if there's a next sibling"
  },
  "$file->hasPrev()": {
    "prefix": "hasPrev()     ",
    "body": "hasPrev()",
    "description": "Checks if there's a previous sibling"
  },
  "$file->hash()": {
    "prefix": "hash()     ",
    "body": "hash()",
    "description": "Returns an md5 hash for the root of the file"
  },
  "$file->header($send = true)": {
    "prefix": "header()     ",
    "body": "header(${1:$send = true})${2}",
    "description": "Sends an appropriate header for the asset"
  },
  "$file->height()": {
    "prefix": "height()     ",
    "body": "height()",
    "description": "Returns the height of image files in pixels"
  },
  "$file->html($attr = array())": {
    "prefix": "html()     ",
    "body": "html(${1:$attr = array()})${2}",
    "description": "Auto-generates an HTML tag for images"
  },
  "$file->imagesize()": {
    "prefix": "imagesize()     ",
    "body": "imagesize()",
    "description": "Returns the PHP imagesize array"
  },
  "$file->is($value)": {
    "prefix": "is()     ",
    "body": "is(${1:$value})${2}",
    "description": "Checks if a file is of a certain type"
  },
  "$file->isExecutable()": {
    "prefix": "isExecutable()     ",
    "body": "isExecutable()",
    "description": "Checks if the file is executable"
  },
  "$file->isLandscape()": {
    "prefix": "isLandscape()     ",
    "body": "isLandscape()",
    "description": "Checks if an image file has been taken in landscape mode"
  },
  "$file->isPortrait()": {
    "prefix": "isPortrait()     ",
    "body": "isPortrait()",
    "description": "Checks if an image file has been taken in portrait mode"
  },
  "$file->isReadable()": {
    "prefix": "isReadable()     ",
    "body": "isReadable()",
    "description": "Checks if the file is readable"
  },
  "$file->isSquare()": {
    "prefix": "isSquare()     ",
    "body": "isSquare()",
    "description": "Checks if the image is square"
  },
  "$file->isWebsafe()": {
    "prefix": "isWebsafe()     ",
    "body": "isWebsafe()",
    "description": "Checks if the file is a jpg, png or gif"
  },
  "$file->isWritable()": {
    "prefix": "isWritable()     ",
    "body": "isWritable()",
    "description": "Checks if the file is writable"
  },
  "$file->kirby()": {
    "prefix": "kirby()     ",
    "body": "kirby()",
    "description": "Returns the kirby object"
  },
  "$file->load($data = array())": {
    "prefix": "load()     ",
    "body": "load(${1:$data = array()})${2}",
    "description": "Safely requires a file if it exists"
  },
  "$file->meta([$language])": {
    "prefix": "meta()     ",
    "body": "meta(${1:$language})${2}",
    "description": "Returns the file's $content object with data from the meta file"
  },
  "$file->mime()": {
    "prefix": "mime()     ",
    "body": "mime()",
    "description": "Returns the file's mime type"
  },
  "$file->modified($format = false, $handler = null)": {
    "prefix": "modified()     ",
    "body": "modified(${1:$format = false}, ${2:$handler = null})${3}",
    "description": "Returns the unix timestamp or a formatted date for when the file has been modified"
  },
  "$file->move($to)": {
    "prefix": "move()     ",
    "body": "move(${1:$to})${2}",
    "description": "Moves the file to a new location"
  },
  "$file->name()": {
    "prefix": "name()     ",
    "body": "name()",
    "description": "Returns the name of the file without extension"
  },
  "$file->next()": {
    "prefix": "next()     ",
    "body": "next()",
    "description": "Returns the next sibling"
  },
  "$file->niceSize()": {
    "prefix": "niceSize()     ",
    "body": "niceSize()",
    "description": "Returns the size of the file in a human readable format"
  },
  "$file->orientation()": {
    "prefix": "orientation()     ",
    "body": "orientation()",
    "description": "Returns the orientation of image files as a string (landscape, portrait, square)"
  },
  "$file->original()": {
    "prefix": "original()     ",
    "body": "original()",
    "description": "Returns the reference to the original file (for thumbnails)"
  },
  "$file->page()": {
    "prefix": "page()     ",
    "body": "page()",
    "description": "Returns the page object for a file"
  },
  "$file->prev()": {
    "prefix": "prev()     ",
    "body": "prev()",
    "description": "Returns the previous sibling"
  },
  "$file->ratio()": {
    "prefix": "ratio()     ",
    "body": "ratio()",
    "description": "Returns the ratio of an image file"
  },
  "$file->read($format = null)": {
    "prefix": "read()     ",
    "body": "read(${1:$format = null})${2}",
    "description": "Reads the content of the file and returns it"
  },
  "$file->remove()": {
    "prefix": "remove()     ",
    "body": "remove()",
    "description": "Alternative for delete"
  },
  "$file->rename($name, $safeName = true)": {
    "prefix": "rename()     ",
    "body": "rename(${1:$name}, ${2:$safeName = true})${3}",
    "description": "Renames the file and all the meta text files"
  },
  "$file->reset()": {
    "prefix": "reset()     ",
    "body": "reset()",
    "description": "Resets the internal memory data cache"
  },
  "$file->resize($width, $height = null, $quality = null)": {
    "prefix": "resize()     ",
    "body": "resize(${1:$width}, ${2:$height = null}, ${3:$quality = null})${4}",
    "description": "Resizes the image by width and optionally by height"
  },
  "$file->root()": {
    "prefix": "root()     ",
    "body": "root()",
    "description": "Returns the full root for a file"
  },
  "$file->safeName()": {
    "prefix": "safeName()     ",
    "body": "safeName()",
    "description": "Returns the filename as safe name"
  },
  "$file->save($content = null, $format = null)": {
    "prefix": "save()     ",
    "body": "save(${1:$content = null}, ${2:$format = null})${3}",
    "description": "Saves new content to the file"
  },
  "$file->scale($by)": {
    "prefix": "scale()     ",
    "body": "scale(${1:$by})${2}",
    "description": "Scales the image up or down by value"
  },
  "$file->show()": {
    "prefix": "show()     ",
    "body": "show()",
    "description": "Read and send the file with the correct headers"
  },
  "$file->siblings()": {
    "prefix": "siblings()     ",
    "body": "siblings()",
    "description": "Returns all siblings of the file"
  },
  "$file->site()": {
    "prefix": "site()     ",
    "body": "site()",
    "description": "Returns the site object"
  },
  "$file->size()": {
    "prefix": "size()     ",
    "body": "size()",
    "description": "Returns the raw file size"
  },
  "$file->textfile([$language])": {
    "prefix": "textfile()     ",
    "body": "textfile(${1:$language})${2}",
    "description": "Returns the root for the meta file of the file"
  },
  "$file->thumb($params)": {
    "prefix": "thumb()     ",
    "body": "thumb(['width' => ${1:300}, 'height' => ${2:200}, 'quality' => ${3:80}])${4}",
    "description": "Sets all parameters for the thumb generator at once."
  },
  "$file->toArray($callback = null)": {
    "prefix": "toArray()     ",
    "body": "toArray(${1:$callback = null})${2}",
    "description": "Converts the entire file object into a plain PHP array"
  },
  "$file->toJson($callback = null)": {
    "prefix": "toJson()     ",
    "body": "toJson(${1:$callback = null})${2}",
    "description": "Converts the entire media object into a JSON string"
  },
  "$file->touch()": {
    "prefix": "touch()     ",
    "body": "touch()",
    "description": "Change the file's modification date to now and create it with an empty content if it is not there yet"
  },
  "$file->type()": {
    "prefix": "type()     ",
    "body": "type()",
    "description": "Returns the file type (image, document, video, archive, code, audio, unkown)"
  },
  "$file->update($data = array()[, $language])": {
    "prefix": "update()     ",
    "body": "update(${1:$data = array()}, ${2:$language})${3}",
    "description": "Updates the meta information for a file"
  },
  "$file->uri()": {
    "prefix": "uri()     ",
    "body": "uri()",
    "description": "Returns the cleaned up relative path for the file"
  },
  "$file->url()": {
    "prefix": "url()     ",
    "body": "url()",
    "description": "Returns the absolute URL for a file"
  },
  "$file->width()": {
    "prefix": "width()     ",
    "body": "width()",
    "description": "Returns the width of image files in pixels"
  },
  "$file->write($content = null, $format = null)": {
    "prefix": "write()     ",
    "body": "write(${1:$content = null}, ${2:$format = null})${3}",
    "description": "Alternative for save"
  },
  "$files->count()": {
    "prefix": "count()      ",
    "body": "count()",
    "description": "Returns the number of files in the collection"
  },
  "$files->filter($callback)": {
    "prefix": "filter()      ",
    "body": "filter(${1:$callback})${2}",
    "description": "Applies a filter callback to each item in the collection"
  },
  "$files->filterBy($key [, $operator], $value [, $split])": {
    "prefix": "filterBy()      ",
    "body": "filterBy(${1:$key}, ${2:$operator}, ${3:$value}, ${4:$split})${5}",
    "description": "Filters the collection by any field and value and with a set of filtering operators"
  },
  "$files->find()": {
    "prefix": "find()      ",
    "body": "find()",
    "description": "Finds a single file or multiple files by one or many filenames."
  },
  "$files->findBy($field, $value)": {
    "prefix": "findBy()      ",
    "body": "findBy(${1:$field}, ${2:$value})${3}",
    "description": "Finds a single file by key and value"
  },
  "$files->first()": {
    "prefix": "first()      ",
    "body": "first()",
    "description": "Returns the first file in the collection"
  },
  "$files->flip()": {
    "prefix": "flip()      ",
    "body": "flip()",
    "description": "Returns the collection in reverse order"
  },
  "$files->get($filename)": {
    "prefix": "get()      ",
    "body": "get(${1:$filename})${2}",
    "description": "Returns a single file by filename"
  },
  "$files->groupBy($field, $caseInsensitive = true)": {
    "prefix": "groupBy()      ",
    "body": "groupBy(${1:$field}, ${2:$caseInsensitive = true})${3}",
    "description": "Groups all files in the collection by a given field."
  },
  "$files->has($file)": {
    "prefix": "has()      ",
    "body": "has(${1:$file})${2}",
    "description": "Checks if a $file object is included in the collection"
  },
  "$files->keys()": {
    "prefix": "keys()      ",
    "body": "keys()",
    "description": "Returns an array with all filenames in the collection."
  },
  "$files->last()": {
    "prefix": "last()      ",
    "body": "last()",
    "description": "Returns the last file in the collection"
  },
  "$files->limit($limit)": {
    "prefix": "limit()      ",
    "body": "limit(${1:$limit})${2}",
    "description": "Returns the collection with a limited set of items"
  },
  "$files->map($callback)": {
    "prefix": "map()      ",
    "body": "map(${1:$callback})${2}",
    "description": "Applies a callback to all items in the collection."
  },
  "$files->not()": {
    "prefix": "not()      ",
    "body": "not()",
    "description": "Returns the collection without a given file. The ignored file can be passed by filename or entire file object."
  },
  "$files->nth($n)": {
    "prefix": "nth()      ",
    "body": "nth(${1:$n})${2}",
    "description": "Returns the nth file in the collection."
  },
  "$files->offset($offset)": {
    "prefix": "offset()      ",
    "body": "offset(${1:$offset})${2}",
    "description": "Returns the collection starting from a given offset"
  },
  "$files->paginate($limit, $options = array())": {
    "prefix": "paginate()      ",
    "body": "paginate(${1:$limit}, ${2:$options = array()})${3}",
    "description": "Applies pagination to the collection"
  },
  "$files->pagination()": {
    "prefix": "pagination()      ",
    "body": "pagination()",
    "description": "Returns the $pagination object"
  },
  "$files->pluck($field, $split = null, $unique = false)": {
    "prefix": "pluck()      ",
    "body": "pluck(${1:$field}, ${2:$split = null}, ${3:$unique = false})${4}",
    "description": "Plucks all values for a specific field from the collection and returns those as array."
  },
  "$files->shuffle()": {
    "prefix": "shuffle()      ",
    "body": "shuffle()",
    "description": "Returns the collection in shuffled order."
  },
  "$files->slice($offset = null, $limit = null)": {
    "prefix": "slice()      ",
    "body": "slice(${1:$offset = null}, ${2:$limit = null})${3}",
    "description": "Returns a sliced version of the collection starting from a given offset and an optional limited number of items."
  },
  "$files->sortBy($field, $direction = 'asc', $method = SORT_REGULAR)": {
    "prefix": "sortBy()      ",
    "body": "sortBy(${1:$field}, ${2:$direction = 'asc'}, ${3:$method = SORT_REGULAR})${4}",
    "description": "Sorts the files in the collection by field and direction"
  },
  "$files->toArray($callback = null)": {
    "prefix": "toArray()      ",
    "body": "toArray(${1:$callback = null})${2}",
    "description": "Converts the collection to a simple array."
  },
  "$files->toJson()": {
    "prefix": "toJson()      ",
    "body": "toJson()",
    "description": "Converts the collection to a json string."
  },
  "attr($name, $value = null)": {
    "prefix": "attr()       ",
    "body": "attr(${1:$name}, ${2:$value = null})${3}",
    "description": "Creates attributes for an HTML tag"
  },
  "brick($tag, $html = false, $attr = array())": {
    "prefix": "brick()       ",
    "body": "brick(${1:$tag}, ${2:$html = false}, ${3:$attr = array()})${4}",
    "description": "Creates an HTML Element (Brick object)"
  },
  "call($function, $arguments = array())": {
    "prefix": "call()       ",
    "body": "call(${1:$function}, ${2:$arguments = array()})${3}",
    "description": "Calls a function with a given set of arguments"
  },
  "csrf($check = null)": {
    "prefix": "csrf()       ",
    "body": "csrf(${1:$check = null})${2}",
    "description": "Generates and checks CSRF tokens"
  },
  "css($path, $media = null)": {
    "prefix": "css()       ",
    "body": "css(${1:$path}, ${2:$media = null})${3}",
    "description": "Creates one or multiple CSS link tags"
  },
  "dump($variable, $echo = true)": {
    "prefix": "dump()       ",
    "body": "dump(${1:$variable}, ${2:$echo = true})${3}",
    "description": "Dumps the content of any variable in a human readable way for debugging"
  },
  "e($condition, $a, $b = null)": {
    "prefix": "e()       ",
    "body": "e(${1:$condition}, ${2:$a}, ${3:$b = null})${4}",
    "description": "Echos one of two alternatives depending on a condition (Shortcut for ecco())"
  },
  "ecco($condition, $a, $b = null)": {
    "prefix": "ecco()       ",
    "body": "ecco(${1:$condition}, ${2:$a}, ${3:$b = null})${4}",
    "description": "Echos one of two alternatives depending on a condition"
  },
  "email($params)": {
    "prefix": "email()       ",
    "body": "email(${1:$params})${2}",
    "description": "Sends an email"
  },
  "esc($string, $context = 'html', $strict = false)": {
    "prefix": "esc()       ",
    "body": "esc(${1:$string}, ${2:$context = 'html'}, ${3:$strict = false})${4}",
    "description": "Escapes strings based on the output context"
  },
  "excerpt($text, $length = 140, $mode = 'chars')": {
    "prefix": "excerpt()       ",
    "body": "excerpt(${1:$text}, ${2:$length = 140}, ${3:$mode = 'chars'})${4}",
    "description": "Creates an excerpt of any text by a given character or word length"
  },
  "get($key = null, $default = null)": {
    "prefix": "get()       ",
    "body": "get(${1:$key = null}, ${2:$default = null})${3}",
    "description": "Fetches a POST or GET parameter by key"
  },
  "gist($url, $file = null)": {
    "prefix": "gist()       ",
    "body": "gist(${1:$url}, ${2:$file = null})${3}",
    "description": "Embeds a Gist from Github by URL"
  },
  "go($url = '/', $code = 302)": {
    "prefix": "go()       ",
    "body": "go(${1:$url = '/'}, ${2:$code = 302})${3}",
    "description": "Redirects to a different URL"
  },
  "gravatar($email, $size = 256, $default = 'mm')": {
    "prefix": "gravatar()       ",
    "body": "gravatar(${1:$email}, ${2:$size = 256}, ${3:$default = 'mm'})${4}",
    "description": "Builds the Gravatar URL by email"
  },
  "h($text, $keepTags = true)": {
    "prefix": "h()       ",
    "body": "h(${1:$text}, ${2:$keepTags = true})${3}",
    "description": "Converts any text to valid HTML (shortcut for html())"
  },
  "html($text, $keepTags = true)": {
    "prefix": "html()       ",
    "body": "html(${1:$text}, ${2:$keepTags = true})${3}",
    "description": "Converts any text to valid HTML"
  },
  "image($filename = null)": {
    "prefix": "image()       ",
    "body": "image(${1:$filename = null})${2}",
    "description": "Fetches any image by filename for the current page, or by path for any other page"
  },
  "invalid($data, $rules, $messages = array())": {
    "prefix": "invalid()       ",
    "body": "invalid(${1:$data}, ${2:$rules}, ${3:$messages = array()})${4}",
    "description": "Runs a number of validators on a set of data and checks if the data is invalid"
  },
  "js($path, $async = false)": {
    "prefix": "js()       ",
    "body": "js(${1:$path}, ${2:$async = false})${3}",
    "description": "Creates a script tag to load a javascript file"
  },
  "kirby()": {
    "prefix": "kirby()       ",
    "body": "kirby()",
    "description": "Returns the Kirby object in any situation"
  },
  "kirbytag($attr)": {
    "prefix": "kirbytag()       ",
    "body": "kirbytag(${1:$attr})${2}",
    "description": "Makes it possible to use any defined Kirbytag as standalone function"
  },
  "kirbytext($text, $page = null)": {
    "prefix": "kirbytext()       ",
    "body": "kirbytext(${1:$text}, ${2:$page = null})${3}",
    "description": "Parses any text with Markdown and Kirbytext"
  },
  "l($key, $default = null)": {
    "prefix": "l()       ",
    "body": "l(${1:$key}, ${2:$default = null})${3}",
    "description": "Fetches a language variable for multi-language sites"
  },
  "markdown($text)": {
    "prefix": "markdown()       ",
    "body": "markdown(${1:$text})${2}",
    "description": "Parses the text as Markdown"
  },
  "memory()": {
    "prefix": "memory()       ",
    "body": "memory()",
    "description": "Returns the current memory usage in a human-readable format"
  },
  "multiline($text)": {
    "prefix": "multiline()       ",
    "body": "multiline(${1:$text})${2}",
    "description": "Converts new lines in text to html breaks."
  },
  "page($uri = null)": {
    "prefix": "page()       ",
    "body": "page(${1:$uri = null})${2}",
    "description": "Fetches any page by URI or the current page when no URI is specified"
  },
  "pages($data = array())": {
    "prefix": "pages()       ",
    "body": "pages(${1:$data = array()})${2}",
    "description": "Helper to build page collections"
  },
  "param($key = null, $default = null)": {
    "prefix": "param()       ",
    "body": "param(${1:$key = null}, ${2:$default = null})${3}",
    "description": "Fetches a Kirby URL parameter"
  },
  "params()": {
    "prefix": "params()       ",
    "body": "params()",
    "description": "Fetches all Kirby URL parameters"
  },
  "r($condition, $a, $b = null)": {
    "prefix": "r()       ",
    "body": "r(${1:$condition}, ${2:$a}, ${3:$b = null})${4}",
    "description": "Returns either $a or $b by the given condition"
  },
  "site()": {
    "prefix": "site()       ",
    "body": "site()",
    "description": "Returns the site object in any situation"
  },
  "size($input)": {
    "prefix": "size()       ",
    "body": "size(${1:$input})${2}",
    "description": "Returns the size of strings, numbers, files and arrays."
  },
  "smartypants($text)": {
    "prefix": "smartypants()       ",
    "body": "smartypants(${1:$text})${2}",
    "description": "Applies the SmartyPants Typographer on an HTML string"
  },
  "snippet($file, $data = array(), $return = false)": {
    "prefix": "snippet()       ",
    "body": "snippet(${1:$file}, ${2:$data = array()}, ${3:$return = false})${4}",
    "description": "Embeds a snippet from the snippet folder"
  },
  "structure($data, $page = null, $key = null)": {
    "prefix": "structure()       ",
    "body": "structure(${1:$data}, ${2:$page = null}, ${3:$key = null})${4}",
    "description": "Creates a Kirby structure object from a data array"
  },
  "textfile($uri, $template, $lang = null)": {
    "prefix": "textfile()       ",
    "body": "textfile(${1:$uri}, ${2:$template}, ${3:$lang = null})${4}",
    "description": "Helper to create correct text file names for content files"
  },
  "thisUrl()": {
    "prefix": "thisUrl()       ",
    "body": "thisUrl()",
    "description": "Returns the current url"
  },
  "thumb($image, $params = array(), $obj = true)": {
    "prefix": "thumb()       ",
    "body": "thumb(${1:$image}, ${2:$params = array()}, ${3:$obj = true})${4}",
    "description": "Creates a thumbnail for a given image object"
  },
  "twitter($username, $text = null, $title = null, $class = null)": {
    "prefix": "twitter()       ",
    "body": "twitter(${1:$username}, ${2:$text = null}, ${3:$title = null}, ${4:$class = null})${5}",
    "description": "Builds a Twitter profile link by username"
  },
  "u($path = '/')": {
    "prefix": "u()       ",
    "body": "u(${1:$path = '/'})${2}",
    "description": "Shortcut for url()"
  },
  "upload($to, $params = array())": {
    "prefix": "upload()       ",
    "body": "upload(${1:$to}, ${2:$params = array()})${3}",
    "description": "Shortcut for the Upload class"
  },
  "url($path = '/')": {
    "prefix": "url()       ",
    "body": "url(${1:$path = '/'})${2}",
    "description": "Builds an absolute URL for a given path"
  },
  "vimeo($url, $width = null, $height = null, $class = null)": {
    "prefix": "vimeo()       ",
    "body": "vimeo(${1:$url}, ${2:$width = null}, ${3:$height = null}, ${4:$class = null})${5}",
    "description": "Embeds a Vimeo video by URL in an iframe"
  },
  "widont($text)": {
    "prefix": "widont()       ",
    "body": "widont(${1:$text})${2}",
    "description": "Avoids typographical widows in strings by replacing the last space with &nbsp;"
  },
  "xml($text)": {
    "prefix": "xml()       ",
    "body": "xml(${1:$text})${2}",
    "description": "Converts any text to valid XML"
  },
  "yaml($string)": {
    "prefix": "yaml()       ",
    "body": "yaml(${1:$string})${2}",
    "description": "Parses any string as YAML"
  },
  "youtube($url, $width = null, $height = null, $class = null)": {
    "prefix": "youtube()       ",
    "body": "youtube(${1:$url}, ${2:$width = null}, ${3:$height = null}, ${4:$class = null})${5}",
    "description": "Embeds a Youtube video by URL in an iframe"
  },
  "$language->code()": {
    "prefix": "code()         ",
    "body": "code()",
    "description": "Returns the iso language code"
  },
  "$language->default()": {
    "prefix": "default()         ",
    "body": "default()",
    "description": "Checks if this is the default language"
  },
  "$language->direction()": {
    "prefix": "direction()         ",
    "body": "direction()",
    "description": "Returns the text direction of the language (rtl or ltr)"
  },
  "$language->locale()": {
    "prefix": "locale()         ",
    "body": "locale()",
    "description": "Returns the locale string"
  },
  "$language->name()": {
    "prefix": "name()         ",
    "body": "name()",
    "description": "Returns the full name of the language"
  },
  "$language->url()": {
    "prefix": "url()         ",
    "body": "url()",
    "description": "Returns the assigned base URL for the language"
  },
  "$location->lat()": {
    "prefix": "lat()          ",
    "body": "lat()",
    "description": "Returns the latitude"
  },
  "$location->lng()": {
    "prefix": "lng()          ",
    "body": "lng()",
    "description": "Returns the longitude"
  },
  "$location->toArray()": {
    "prefix": "toArray()          ",
    "body": "toArray()",
    "description": "Returns latitude and longitude as associative array"
  },
  "$page->archives()": {
    "prefix": "archives()            ",
    "body": "archives()",
    "description": "Returns a $files collection with all archive files (zip, gzip, tar) in the page's directory"
  },
  "$page->audio()": {
    "prefix": "audio()            ",
    "body": "audio()",
    "description": "Returns a $files collection with all audio files in the page's directory"
  },
  "$page->children()": {
    "prefix": "children()            ",
    "body": "children()",
    "description": "Returns a $pages collection with all children of the page"
  },
  "$page->code()": {
    "prefix": "code()            ",
    "body": "code()",
    "description": "Returns a $files collection with all code files (css, js, html, etc.) in the page's directory"
  },
  "$page->content([$lang = null])": {
    "prefix": "content()            ",
    "body": "content(${1:$lang = null})${2}",
    "description": "Returns the page's $content object"
  },
  "$page->content()->has($field)": {
    "prefix": "has()            ",
    "body": "has(${1:$field})${2}",
    "description": "Checks if the page has a certain field"
  },
  "$page->contentURL()": {
    "prefix": "contentURL()            ",
    "body": "contentURL()",
    "description": "Returns the full URL for the content folder"
  },
  "$page->create($uri, $template, $data = array())": {
    "prefix": "create()            ",
    "body": "create(${1:$uri}, ${2:$template}, ${3:$data = array()})${4}",
    "description": "Creates a new page object"
  },
  "$page->date($format = null, $field = 'date')": {
    "prefix": "date()            ",
    "body": "date(${1:$format = null}, ${2:$field = 'date'})${3}",
    "description": "Returns a unix timestamp or formatted date string from the page's date field or any other field containing a parsable date"
  },
  "$page->decrement($field, $by = 1, $max = null)": {
    "prefix": "decrement()            ",
    "body": "decrement(${1:$field}, ${2:$by = 1}, ${3:$max = null})${4}",
    "description": "Decrement a field value by one or a given value"
  },
  "$page->delete($force = false)": {
    "prefix": "delete()            ",
    "body": "delete(${1:$force = false})${2}",
    "description": "Deletes the $page object and all its data and files. This cannot be undone!"
  },
  "$page->depth()": {
    "prefix": "depth()            ",
    "body": "depth()",
    "description": "Returns a number, which represents the nesting depth of the page"
  },
  "$page->dirname()": {
    "prefix": "dirname()            ",
    "body": "dirname()",
    "description": "Returns the full name of the page's directory"
  },
  "$page->diruri()": {
    "prefix": "diruri()            ",
    "body": "diruri()",
    "description": "Returns the full directory path of the page starting at /content"
  },
  "$page->document($filename = false)": {
    "prefix": "document()            ",
    "body": "document(${1:$filename = false})${2}",
    "description": "Returns a specific document $file object by filename. If no filename is given, the first available document will be returned."
  },
  "$page->documents()": {
    "prefix": "documents()            ",
    "body": "documents()",
    "description": "Returns a $files collection with all documents in the page's directory"
  },
  "$page->equals($other)": {
    "prefix": "equals()            ",
    "body": "equals(${1:$other})${2}",
    "description": "Compares the page with another $page object and checks if they are the same"
  },
  "$page->file($filename = false)": {
    "prefix": "file()            ",
    "body": "file(${1:$filename = false})${2}",
    "description": "Returns a specific $file object within the page's directory by filename. If no filename is given, the first file will be returned"
  },
  "$page->files()": {
    "prefix": "files()            ",
    "body": "files()",
    "description": "Returns a $files collection with all files in the page's directory"
  },
  "$page->find($uri)": {
    "prefix": "find()            ",
    "body": "find(${1:$uri})${2}",
    "description": "Returns the $page object of a specific subpage by URI. If multiple URIs are given, the method will return a $pages collection with all matches."
  },
  "$page->grandChildren()": {
    "prefix": "grandChildren()            ",
    "body": "grandChildren()",
    "description": "Returns a $pages collection with all children of children in the page's directory"
  },
  "$page->hasArchives()": {
    "prefix": "hasArchives()            ",
    "body": "hasArchives()",
    "description": "Checks if there are any archive files (zip, gzip, tar) in the page's directory"
  },
  "$page->hasAudio()": {
    "prefix": "hasAudio()            ",
    "body": "hasAudio()",
    "description": "Checks if there are any audio files in the page's directory"
  },
  "$page->hasChildren()": {
    "prefix": "hasChildren()            ",
    "body": "hasChildren()",
    "description": "Checks if the page has children"
  },
  "$page->hasCode()": {
    "prefix": "hasCode()            ",
    "body": "hasCode()",
    "description": "Checks if there are any audio files in the page's directory"
  },
  "$page->hasDocuments()": {
    "prefix": "hasDocuments()            ",
    "body": "hasDocuments()",
    "description": "Checks if there are any documents (pdf, doc, xls, etc.) in the page's directory"
  },
  "$page->hasFiles()": {
    "prefix": "hasFiles()            ",
    "body": "hasFiles()",
    "description": "Checks if there are any files in the page's directory"
  },
  "$page->hasImages()": {
    "prefix": "hasImages()            ",
    "body": "hasImages()",
    "description": "Checks if there are image files (jpg, png, gif, etc.) in the page directory"
  },
  "$page->hasInvisibleChildren()": {
    "prefix": "hasInvisibleChildren()            ",
    "body": "hasInvisibleChildren()",
    "description": "Checks if the page has any invisible children"
  },
  "$page->hasNext([$sort, $direction])": {
    "prefix": "hasNext()            ",
    "body": "hasNext(${1:$sort}, ${2:$direction})${3}",
    "description": "Checks if the page has a next sibling"
  },
  "$page->hasNextInvisible([$sort, $direction])": {
    "prefix": "hasNextInvisible()            ",
    "body": "hasNextInvisible(${1:$sort}, ${2:$direction})${3}",
    "description": "Checks if the page has a next invisible sibling"
  },
  "$page->hasNextVisible([$sort, $direction])": {
    "prefix": "hasNextVisible()            ",
    "body": "hasNextVisible(${1:$sort}, ${2:$direction})${3}",
    "description": "Checks if the page has a next visible sibling"
  },
  "$page->hasPrev([$sort, $direction])": {
    "prefix": "hasPrev()            ",
    "body": "hasPrev(${1:$sort}, ${2:$direction})${3}",
    "description": "Checks if the page has a previous sibling"
  },
  "$page->hasPrevInvisible([$sort, $direction])": {
    "prefix": "hasPrevInvisible()            ",
    "body": "hasPrevInvisible(${1:$sort}, ${2:$direction})${3}",
    "description": "Checks if the page has a previous invisible sibling"
  },
  "$page->hasPrevVisible([$sort, $direction])": {
    "prefix": "hasPrevVisible()            ",
    "body": "hasPrevVisible(${1:$sort}, ${2:$direction})${3}",
    "description": "Checks if the page has a previous visible sibling"
  },
  "$page->hasTemplate()": {
    "prefix": "hasTemplate()            ",
    "body": "hasTemplate()",
    "description": "Checks if the page has its own template or if it uses the default template"
  },
  "$page->hasVideos()": {
    "prefix": "hasVideos()            ",
    "body": "hasVideos()",
    "description": "Checks if there are any video files in the page directory"
  },
  "$page->hasVisibleChildren()": {
    "prefix": "hasVisibleChildren()            ",
    "body": "hasVisibleChildren()",
    "description": "Checks if the page has any visible children"
  },
  "$page->hash()": {
    "prefix": "hash()            ",
    "body": "hash()",
    "description": "Returns a unique hash for the page, which is used by tinyurls"
  },
  "$page->headers()": {
    "prefix": "headers()            ",
    "body": "headers()",
    "description": "Sends all appropriate headers for this page. Can be configured with the headers config array, which should contain all header definitions for each template"
  },
  "$page->hide()": {
    "prefix": "hide()            ",
    "body": "hide()",
    "description": "Removes the sorting number from the page directory to switch it to invisible"
  },
  "$page->id()": {
    "prefix": "id()            ",
    "body": "id()",
    "description": "Returns the page id, which is the untranslated URI"
  },
  "$page->image($filename = false)": {
    "prefix": "image()            ",
    "body": "image(${1:$filename = false})${2}",
    "description": "Returns a specific image $file object by filename. If no filename is given, the first available image will be returned."
  },
  "$page->images()": {
    "prefix": "images()            ",
    "body": "images()",
    "description": "Returns a $files collection with all image files (jpg, png, gif, etc.) in the page directory"
  },
  "$page->increment($field, $by = 1, $max = null)": {
    "prefix": "increment()            ",
    "body": "increment(${1:$field}, ${2:$by = 1}, ${3:$max = null})${4}",
    "description": "Increment a field value by one or a given value"
  },
  "$page->index()": {
    "prefix": "index()            ",
    "body": "index()",
    "description": "Recursively builds a $pages collection with all children, children of children, etc."
  },
  "$page->intendedTemplate()": {
    "prefix": "intendedTemplate()            ",
    "body": "intendedTemplate()",
    "description": "Returns the name of the intended template. This is the name of the content text file."
  },
  "$page->intendedTemplateFile()": {
    "prefix": "intendedTemplateFile()            ",
    "body": "intendedTemplateFile()",
    "description": "Returns the path for the intended template file"
  },
  "$page->inventory()": {
    "prefix": "inventory()            ",
    "body": "inventory()",
    "description": "Reads the directory and returns an inventory array"
  },
  "$page->is($other)": {
    "prefix": "is()            ",
    "body": "is(${1:$other})${2}",
    "description": "Compares the page with another $page object and checks if they are the same"
  },
  "$page->isActive()": {
    "prefix": "isActive()            ",
    "body": "isActive()",
    "description": "Checks if the page is the currently active page"
  },
  "$page->isAncestorOf($child)": {
    "prefix": "isAncestorOf()            ",
    "body": "isAncestorOf(${1:$child})${2}",
    "description": "Checks if the page is a direct or indirect ancestor of the given $page object"
  },
  "$page->isCacheable()": {
    "prefix": "isCacheable()            ",
    "body": "isCacheable()",
    "description": "Checks if the page can be cached"
  },
  "$page->isChildOf($parent)": {
    "prefix": "isChildOf()            ",
    "body": "isChildOf(${1:$parent})${2}",
    "description": "Checks if the page is a child of the given page"
  },
  "$page->isDeletable()": {
    "prefix": "isDeletable()            ",
    "body": "isDeletable()",
    "description": "Checks if the page is deletable"
  },
  "$page->isDescendantOf($parent)": {
    "prefix": "isDescendantOf()            ",
    "body": "isDescendantOf(${1:$parent})${2}",
    "description": "Checks if the page is a descendant of the given page"
  },
  "$page->isDescendantOfActive()": {
    "prefix": "isDescendantOfActive()            ",
    "body": "isDescendantOfActive()",
    "description": "Checks if the page is a descendant of the currently active page"
  },
  "$page->isErrorPage()": {
    "prefix": "isErrorPage()            ",
    "body": "isErrorPage()",
    "description": "Checks if the page is the error page"
  },
  "$page->isHomePage()": {
    "prefix": "isHomePage()            ",
    "body": "isHomePage()",
    "description": "Checks if the page is the home page"
  },
  "$page->isInvisible()": {
    "prefix": "isInvisible()            ",
    "body": "isInvisible()",
    "description": "Checks if the page is invisible"
  },
  "$page->isOpen()": {
    "prefix": "isOpen()            ",
    "body": "isOpen()",
    "description": "Checks if the page is open. This means that it is either active or it is a direct or indirect parent of the currently active page."
  },
  "$page->isParentOf($child)": {
    "prefix": "isParentOf()            ",
    "body": "isParentOf(${1:$child})${2}",
    "description": "Checks if the page is the parent of the given page"
  },
  "$page->isSite()": {
    "prefix": "isSite()            ",
    "body": "isSite()",
    "description": "Checks if this page object is the main site"
  },
  "$page->isVisible()": {
    "prefix": "isVisible()            ",
    "body": "isVisible()",
    "description": "Checks if the page is visible"
  },
  "$page->isWritable()": {
    "prefix": "isWritable()            ",
    "body": "isWritable()",
    "description": "Checks if the page is writable"
  },
  "$page->kirby()": {
    "prefix": "kirby()            ",
    "body": "kirby()",
    "description": "Returns the kirby object"
  },
  "$page->modified($format = false)": {
    "prefix": "modified()            ",
    "body": "modified(${1:$format = false})${2}",
    "description": "Returns the unix timestamp or a formatted date string of the last modification date of the page"
  },
  "$page->move($uid)": {
    "prefix": "move()            ",
    "body": "move(${1:$uid})${2}",
    "description": "Changes the uid for the page"
  },
  "$page->next([$sort, $direction])": {
    "prefix": "next()            ",
    "body": "next(${1:$sort}, ${2:$direction})${3}",
    "description": "Returns the next sibling"
  },
  "$page->nextInvisible([$sort, $direction])": {
    "prefix": "nextInvisible()            ",
    "body": "nextInvisible(${1:$sort}, ${2:$direction})${3}",
    "description": "Returns the next invisible sibling"
  },
  "$page->nextVisible([$sort, $direction])": {
    "prefix": "nextVisible()            ",
    "body": "nextVisible(${1:$sort}, ${2:$direction})${3}",
    "description": "Returns the next visible sibling"
  },
  "$page->num()": {
    "prefix": "num()            ",
    "body": "num()",
    "description": "Returns the sorting number"
  },
  "$page->parent()": {
    "prefix": "parent()            ",
    "body": "parent()",
    "description": "Returns the parent $page object"
  },
  "$page->parents()": {
    "prefix": "parents()            ",
    "body": "parents()",
    "description": "Returns a $pages collection of all parents"
  },
  "$page->prev([$sort, $direction])": {
    "prefix": "prev()            ",
    "body": "prev(${1:$sort}, ${2:$direction})${3}",
    "description": "Returns the previous sibling"
  },
  "$page->prevInvisible([$sort, $direction])": {
    "prefix": "prevInvisible()            ",
    "body": "prevInvisible(${1:$sort}, ${2:$direction})${3}",
    "description": "Returns the previous invisble sibling."
  },
  "$page->prevVisible([$sort, $direction])": {
    "prefix": "prevVisible()            ",
    "body": "prevVisible(${1:$sort}, ${2:$direction})${3}",
    "description": "Returns the previous visible sibling"
  },
  "$page->reset()": {
    "prefix": "reset()            ",
    "body": "reset()",
    "description": "Cleans the temporary page cache and the cache of all parent pages"
  },
  "$page->root()": {
    "prefix": "root()            ",
    "body": "root()",
    "description": "Returns the full root of the page directory"
  },
  "$page->search($query, $params = array())": {
    "prefix": "search()            ",
    "body": "search(${1:$query}, ${2:$params = array()})${3}",
    "description": "Searches all descendants"
  },
  "$page->siblings($self = true)": {
    "prefix": "siblings()            ",
    "body": "siblings(${1:$self = true})${2}",
    "description": "Returns all siblings."
  },
  "$page->site()": {
    "prefix": "site()            ",
    "body": "site()",
    "description": "Returns the site object"
  },
  "$page->slug([$lang = null])": {
    "prefix": "slug()            ",
    "body": "slug(${1:$lang = null})${2}",
    "description": "Returns the slug. The slug is the last part of the page's URL. It is translatable in multi-language sites while the UID always stays the page's directory name without the sorting number."
  },
  "$page->sort($num = null)": {
    "prefix": "sort()            ",
    "body": "sort(${1:$num = null})${2}",
    "description": "Changes the sorting number of the page."
  },
  "$page->template()": {
    "prefix": "template()            ",
    "body": "template()",
    "description": "Returns the name of the used template for the page. Will return default if the intended template cannot be found."
  },
  "$page->templateData()": {
    "prefix": "templateData()            ",
    "body": "templateData()",
    "description": "Additional data, which will be passed to the template"
  },
  "$page->templateFile()": {
    "prefix": "templateFile()            ",
    "body": "templateFile()",
    "description": "Returns the full path of the template file."
  },
  "$page->textfile($template = null [, $lang = null])": {
    "prefix": "textfile()            ",
    "body": "textfile(${1:$template = null}, ${2:$lang = null})${3}",
    "description": "Returns the root for the content file"
  },
  "$page->tinyurl()": {
    "prefix": "tinyurl()            ",
    "body": "tinyurl()",
    "description": "Returns the tinyurl for the page if tinyurls are activated in the config"
  },
  "$page->title()": {
    "prefix": "title()            ",
    "body": "title()",
    "description": "Returns the page title. The title is fetched from the content unless it does not exist. In this case it will be overwritten by the UID."
  },
  "$page->toArray($callback = null)": {
    "prefix": "toArray()            ",
    "body": "toArray(${1:$callback = null})${2}",
    "description": "Converts the entire page object into a plain PHP array"
  },
  "$page->toJson($callback = null)": {
    "prefix": "toJson()            ",
    "body": "toJson(${1:$callback = null})${2}",
    "description": "Converts the entire page array into a json string"
  },
  "$page->touch()": {
    "prefix": "touch()            ",
    "body": "touch()",
    "description": "Marks the page as modified"
  },
  "$page->uid()": {
    "prefix": "uid()            ",
    "body": "uid()",
    "description": "The UID is the page directory name without the sorting number."
  },
  "$page->update($data = array() [, $lang = null])": {
    "prefix": "update()            ",
    "body": "update(${1:$data = array()}, ${2:$lang = null})${3}",
    "description": "Updates the page content with all passed variables."
  },
  "$page->uri([$lang = null])": {
    "prefix": "uri()            ",
    "body": "uri(${1:$lang = null})${2}",
    "description": "Returns the URI. The URI is the relative URL without the host or any subfolders."
  },
  "$page->url()": {
    "prefix": "url()            ",
    "body": "url()",
    "description": "Returns the full URL of the page"
  },
  "$page->urlKey($lang = null)": {
    "prefix": "urlKey()            ",
    "body": "urlKey(${1:$lang = null})${2}",
    "description": "Returns the URL key from the content file if available and otherwise returns the page UID"
  },
  "$page->video($filename = false)": {
    "prefix": "video()            ",
    "body": "video(${1:$filename = false})${2}",
    "description": "Returns a specific video $file object by filename. If no filename is given, the first available video will be returned."
  },
  "$page->videos()": {
    "prefix": "videos()            ",
    "body": "videos()",
    "description": "Returns a $files collection with all videos in the page directory."
  },
  "$pages->add($page)": {
    "prefix": "add()             ",
    "body": "add(${1:$page})${2}",
    "description": "Adds a single page object or a collection to a collection"
  },
  "$pages->append($key, $object)": {
    "prefix": "append()             ",
    "body": "append(${1:$key}, ${2:$object})${3}",
    "description": "Appends an element to the data array"
  },
  "$pages->children()": {
    "prefix": "children()             ",
    "body": "children()",
    "description": "Returns a $pages collection with all children of each page in the collection"
  },
  "$pages->chunk($size)": {
    "prefix": "chunk()             ",
    "body": "chunk(${1:$size})${2}",
    "description": "Creates chunks of the same size and returns them in a new collection"
  },
  "$pages->count()": {
    "prefix": "count()             ",
    "body": "count()",
    "description": "Returns the number of pages in the collection"
  },
  "$pages->create($uid, $template, $data = array())": {
    "prefix": "create()             ",
    "body": "create(${1:$uid}, ${2:$template}, ${3:$data = array()})${4}",
    "description": "Creates a new subpage"
  },
  "$pages->current()": {
    "prefix": "current()             ",
    "body": "current()",
    "description": "Returns the current element of the array"
  },
  "pages::extractValue($item, $field)": {
    "prefix": "pages::extractValue()             ",
    "body": "pages::extractValue(${1:$item}, ${2:$HERE})${3}",
    "description": "Makes sure to provide a valid value for each filter method no matter if an object or an array is given"
  },
  "$pages->files()": {
    "prefix": "files()             ",
    "body": "files()",
    "description": "Returns a $files collection with all files of each page in the collection"
  },
  "$pages->filter($callback)": {
    "prefix": "filter()             ",
    "body": "filter(${1:$callback})${2}",
    "description": "Filters the collection with a custom filter callback"
  },
  "$pages->filterBy($key [, $operator], $value [, $split])": {
    "prefix": "filterBy()             ",
    "body": "filterBy(${1:$key}, ${2:$operator}, ${3:$value}, ${4:$split})${5}",
    "description": "Filters the collection by any field and value and with a set of filtering operators"
  },
  "$pages->find($page)": {
    "prefix": "find()             ",
    "body": "find(${1:$page})${2}",
    "description": "Finds a $page object in the collection by UID or relative URI"
  },
  "$pages->findBy($key, $value)": {
    "prefix": "findBy()             ",
    "body": "findBy(${1:$key}, ${2:$HERE})${3}",
    "description": "Finds a single $page object in the collection by $key and $value"
  },
  "$pages->findByURI($uri)": {
    "prefix": "findByURI()             ",
    "body": "findByURI(${1:$uri})${2}",
    "description": "Finds a $page object in the collection by its full URI"
  },
  "$pages->findOpen()": {
    "prefix": "findOpen()             ",
    "body": "findOpen()",
    "description": "Finds the open $page object in the collection"
  },
  "$pages->first()": {
    "prefix": "first()             ",
    "body": "first()",
    "description": "Returns the first $page object from the collection"
  },
  "$pages->flip()": {
    "prefix": "flip()             ",
    "body": "flip()",
    "description": "Returns the collection in reverse order"
  },
  "$pages->get($key, $default = null)": {
    "prefix": "get()             ",
    "body": "get(${1:$key}, ${2:$default = null})${3}",
    "description": "Returns a $page object by its full URI"
  },
  "$pages->group($callback)": {
    "prefix": "group()             ",
    "body": "group(${1:$callback})${2}",
    "description": "Groups the collection by a given callback"
  },
  "$pages->groupBy($field, $caseInsensitive = true)": {
    "prefix": "groupBy()             ",
    "body": "groupBy(${1:$field}, ${2:$caseInsensitive = true})${3}",
    "description": "Groups $page objects in the collection by any field and returns them in a new collection"
  },
  "$pages->has($page)": {
    "prefix": "has()             ",
    "body": "has(${1:$page})${2}",
    "description": "Checks if a $page object is included in the collection"
  },
  "$pages->index()": {
    "prefix": "index()             ",
    "body": "index()",
    "description": "Recursively creates a full index from all pages and subpages in the collection and returns it as a new flat $pages collection"
  },
  "$pages->indexOf($needle)": {
    "prefix": "indexOf()             ",
    "body": "indexOf(${1:$needle})${2}",
    "description": "Tries to find the index number for the given element"
  },
  "$pages->invisible()": {
    "prefix": "invisible()             ",
    "body": "invisible()",
    "description": "Returns all invisible $page objects from the collection"
  },
  "$pages->key()": {
    "prefix": "key()             ",
    "body": "key()",
    "description": "Returns the current key from the array"
  },
  "$pages->keyOf($needle)": {
    "prefix": "keyOf()             ",
    "body": "keyOf(${1:$needle})${2}",
    "description": "Tries to find the key for the given element"
  },
  "$pages->keys()": {
    "prefix": "keys()             ",
    "body": "keys()",
    "description": "Returns all keys/URIs from the collection"
  },
  "$pages->last()": {
    "prefix": "last()             ",
    "body": "last()",
    "description": "Returns the last $page object from the collection"
  },
  "$pages->limit($limit)": {
    "prefix": "limit()             ",
    "body": "limit(${1:$limit})${2}",
    "description": "Returns the collection with a limited amount of pages"
  },
  "$pages->map($callback)": {
    "prefix": "map()             ",
    "body": "map(${1:$callback})${2}",
    "description": "Returns a new collection and applies the mapping callback to all pages"
  },
  "$pages->merge($collection2)": {
    "prefix": "merge()             ",
    "body": "merge(${1:$collection2})${2}",
    "description": "Returns a new combined collection"
  },
  "$pages->next()": {
    "prefix": "next()             ",
    "body": "next()",
    "description": "Moves the cursor to the next element in the array and returns it"
  },
  "$pages->not($args)": {
    "prefix": "not()             ",
    "body": "not(${1:$args})${2}",
    "description": "Returns the collection without any given pages."
  },
  "$pages->nth($n)": {
    "prefix": "nth()             ",
    "body": "nth(${1:$n})${2}",
    "description": "Returns the nth page in the collection"
  },
  "$pages->offset($offset)": {
    "prefix": "offset()             ",
    "body": "offset(${1:$offset})${2}",
    "description": "Returns the collection starting from the given offset"
  },
  "$pages->paginate($limit, $options = array())": {
    "prefix": "paginate()             ",
    "body": "paginate(${1:$limit}, ${2:$HERE})${3}",
    "description": "Adds a $pagination object to the collection, which makes it easy to page through items"
  },
  "$pages->pagination()": {
    "prefix": "pagination()             ",
    "body": "pagination()",
    "description": "Returns the $pagination object if available"
  },
  "$pages->pluck($field, $split = null, $unique = false)": {
    "prefix": "pluck()             ",
    "body": "pluck(${1:$field}, ${2:$split = null}, ${3:$unique = false})${4}",
    "description": "Extracts an array of values from each item by field"
  },
  "$pages->prepend($key, $object)": {
    "prefix": "prepend()             ",
    "body": "prepend(${1:$key}, ${2:$object})${3}",
    "description": "Prepends an element to the data array"
  },
  "$pages->prev()": {
    "prefix": "prev()             ",
    "body": "prev()",
    "description": "Moves the cursor to the previous element in the array and returns it"
  },
  "$pages->rewind()": {
    "prefix": "rewind()             ",
    "body": "rewind()",
    "description": "Moves the cursor to the first element of the array"
  },
  "$pages->search($query, $params = array())": {
    "prefix": "search()             ",
    "body": "search(${1:$query}, ${2:$params = array()})${3}",
    "description": "Searches all pages in the collection and all descendants"
  }

}
